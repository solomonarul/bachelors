\documentclass[12pt]{scrreport} 

% Set up styles.
\usepackage[language=english, type=bachelor]{universitystyle} % language may be romanian or english (default is english), type may be bachelor or master (default is bachelor)
\input{customstyle}
\usepackage{graphicx}
\graphicspath{ {./pictures/} }

% Latex fixes for sucking.
\usepackage{float}
\usepackage{longtable}
\usepackage[table,xcdraw]{xcolor}
\usepackage{indentfirst}
\usepackage{tikz}
\usetikzlibrary{positioning, arrows.meta}

% Set up the article.
\pagestyle{fancy}
\lhead{}
\chead{}
\renewcommand{\headrulewidth}{0.2pt}
\renewcommand{\footrulewidth}{0.2pt}

\begin{document}

% Title page.
\specialization{ENGLISH}	
\title{Design, implementation and comparision of different software emulating methods}					   
\author{Oniga Andrei-Mihai}											
\supervisor{Lect. dr. Mihai Andrei}				
				
\maketitle

\newpage
\thispagestyle{empty}
\mbox{}
\newpage
\pagenumbering{roman}

% Abstract.
\cleardoublepage
ABSTRACT
\vspace{0.5cm}	
\hrule
\vspace{0.5cm}

\par This thesis explores foundational software emulation techniques, with a particular focus on interpretation and just-in-time (JIT) compilation. The objective is to examine the trade-offs between these approaches in terms of performance and implementation complexity, 

\par To evaluate these techniques in a controlled and educational context, interpreters and JIT compilers were implemented for two minimalistic and well-documented languages, especially well suited to beginners in emulation and thereby offering a comprehensive introduction to emulator design: \textit{Brainfuck and CHIP-8}. They have been selected due to their simplicity, which enables the study to center on emulator behavior rather than language-specific intricacies.

\par The paper's analysis includes performance benchmarking, implementation complexity, and the impact of a selection of optimizations such as instruction folding, jump precalculation, hot loop replacement, and efficient register allocation in the case of JITs. Empirical results also demonstrate that JIT compilation significantly outperforms interpretation, particularly for longer-running programs, primarily due to reduced instruction-fetching and decoding overhead.

\par However, the study also highlights diminishing returns from aggressive optimization strategies such as excessive hot loop replacement which eventually leads to scenarios where entire programs are reduced to singular instructions, limiting further gains. Additionally, some code replacements were found to generate equivalent machine code to the original instruction sequences, rendering the optimization ineffective while increasing code complexity.

\par These findings underscore the balance between simplicity and performance, while aiming to offer accessible insights for readers new to emulation concepts, particularly those engaged in experimental or hobbyist development with languages like the two selected languages.

\par All components discussed have been implemented within a dedicated \textit{C} application, whose architectural design and implementation details are thoroughly documented and analyzed. This practical framework serves to illustrate the theoretical concepts presented, providing a concrete basis for understanding the trade-offs and design decisions inherent in emulator development.

\vspace{0.5em}

\textit{Note: Some of the paper's content has been rewritten and refined to enhance academic clarity and tone by an AI language model. All of the ideas and their implementations have been originally thought of and implemented by the author.}

\vspace{0.5em}

\textbf{Keywords}: computer engineering, software emulation, interpretation, JIT compilation, Brainfuck, CHIP-8, C, performance analysis, optimization techniques

% Table of contents.
\tableofcontents
\newpage
\pagenumbering{arabic}

% Contents.
\input{chapters/1_intro}
\input{chapters/2_bf}
\input{chapters/3_chip}
\input{chapters/4_app}
\input{chapters/5_conclusions}

\bibliography{../references}

\end{document}
